Great question!
When you want to **update state based on its previous value** (like incrementing a count), you should always use the **functional form of `setState()`** to avoid bugs.

---

## ðŸ§  **What does it mean?**

Instead of this (âŒ sometimes wrong):

```js
setCount(count + 1);
```

Use this (âœ… always safe):

```js
setCount(prevCount => prevCount + 1);
```

Because React state updates are **asynchronous**, using the previous value directly ensures you always get the **latest state**.

---

## âœ… Small Example: Counter Component

```jsx
import React, { useState } from 'react';

const Counter = () => {
  // Start with count = 0
  const [count, setCount] = useState(0);

  // Correctly update based on previous value
  const handleIncrement = () => {
    setCount(prevCount => prevCount + 1); // âœ… safest way
  };

  const handleDecrement = () => {
    setCount(prevCount => prevCount - 1); // âœ…
  };

  return (
    <div className="p-4 text-center">
      <h2 className="text-xl font-bold">Counter: {count}</h2>
      <button onClick={handleIncrement} className="bg-green-500 text-white px-4 py-2 m-2 rounded">
        + Increment
      </button>
      <button onClick={handleDecrement} className="bg-red-500 text-white px-4 py-2 m-2 rounded">
        - Decrement
      </button>
    </div>
  );
};

export default Counter;
```

---

## ðŸ”Ž Key Line:

```js
setCount(prevCount => prevCount + 1);
```

Here:

* `prevCount` â†’ automatically gets the **latest value**
* You're returning the **new state** based on the old one

---

## ðŸ’¡ Use this pattern when:

* Incrementing/decrementing numbers
* Toggling boolean: `setShow(prev => !prev)`
* Updating objects or arrays based on previous state

---

Let me know if you want this concept in:

* ðŸ“„ Hindi explanation
* ðŸ§ª Quiz style
* âœ… Practice challenge

Also: Want to learn **how to update an object or array state safely** next?
